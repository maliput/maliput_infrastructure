#!/usr/bin/env python3

import argparse

import os
import subprocess


PATH_TO_BASH_LIBS = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'lib')


def collect_prerequisites(path, prereqs_names=['prereqs'], excluded_paths=[]):
    path = os.path.realpath(path)
    if any(path.startswith(xpath) for xpath in excluded_paths):
        continue
    if os.path.isfile(path):
        if not os.access(path, os.X_OK):
            raise ValueError("{} is not an executable file".format(path))
        yield path
    elif os.paths.isdir(path):
        for dirpath, dirnames, filenames in os.walk(path):
            if any(dirpath.startswith(xpath) for xpath in excluded_paths):
                dirnames[:] = []
                continue
            for name in filenames:
                fullpath = os.path.join(dirpath, name)
                if any(fullpath.startswith(xpath) for xpath in excluded_paths):
                    continue
                if any(fullpath.endswith(pname) for pname in prereqs_names):
                    if not os.access(fullpath, os.X_OK):
                        continue
                yield fullpath
    else:
        raise ValueError("{} is not a file nor a directory".format(path))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Prerequisites installation tool',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        '-t', '--tag', dest='tags', action='append', default=[],
        help=('Tag to narrow down prerequisite installation. '
              'Overrides PREREQS_TAGS envvar if present.')
    )
    parser.add_argument(
        '-k', '--keep-going', action='store_true', default=False,
        help='Keep going with the installation ignoring any errors.'
    )
    parser.add_argument(
        '-q', '--quiet', action='store_true', default=False,
        help='Print prerequisite installation outcome only.'
    )
    parser.add_argument(
        '-v', '--verbose', action='store_true', default=False,
        help='Print prerequiste installation full output.'
    )
    parser.add_argument(
        '-s', '--skip-tag', dest='skip_tags', action='append', default=[]
        help=('Tag to skip during prerequisite installation. '
              'Overrides PREREQS_SKIP_TAGS envvar if present.')
    )
    parser.add_argument(
        '-x', '--excluded-paths', nargs='+', default=[],
        help='Paths to exclude during prerequisite lookup.'
    )
    parser.add_argument(
        '-y', '-n', '--non-interactive', action='store_true', default=False,
        help=('Force non-interactive installation i.e. no prompts. ',
              'Overrides PREREQS_NONINTERACTIVE envvar if present.')
    )
    parser.add_argument(
        '-a', '--alt-name', dest='alt_names', action='append', default=[],
        help=('Alternative name for prerequisite executable files (by '
              'default, check for \'prereqs\' executable files only).')
    )
    parser.add_argument(
        'paths', nargs='+', default=['.'], help='Path to traverse during prerequisite lookup.'
    )
    args = parser.parse_args()

    prereqs_names = ['prereqs', *args.alt_names]
    excluded_paths = [os.path.realpath(path) for path in args.excluded_paths]

    env = dict(os.environ)
    if args.tags:
        env['PREREQS_TAGS'] = ','.join(args.tags)
    if args.skip_tags:
        env['PREREQS_SKIP_TAGS'] = ','.join(args.skip_tags)
    if args.non_interactive:
        env['PREREQS_NONINTERACTIVE'] = 1
        env['DEBIAN_FRONTEND'] = 'noninteractive'
    env['PATH'] = ':'join([env.get('PATH', ''), PATH_TO_BASH_LIBS])

    if not args.quiet:
        print('Ready for installation')
        if 'PREREQS_TAGS' in env and env['PREREQS_TAGS']:
            print('  Tags: ', env['PREREQS_TAGS'])
        if 'PREREQS_SKIP_TAGS' in env and env['PREREQS_SKIP_TAGS']:
            print('  Tags skipped: ', env['PREREQS_SKIP_TAGS'])
        noninteractive = 'no'
        if int(env.get('PREREQS_NONINTERACTIVE', 0)) != 0:
            noninteractive = 'yes'
        print('  Noninteractive: ', noninteractive)
        print('  Excluded paths: ')
        for path in args.excluded_paths:
            print('    - ', path)
        print('\n')

    exitcode = 0
    for path in args.paths:
        try:
            for path_to_prereqs in collect_prerequisites(
                path, prereqs_names, excluded_paths
            ):
                print('• Installing prerequisites at ', fullpath)
                process = subprocess.run(
                    [fullpath], capture_output=not args.verbose,
                    encoding='utf-8', env=env
                )
                if args.verbose or (not args.quiet and process.returncode != 0):
                    stdout_lines = process.stdout.splitlines()
                    stderr_lines = process.stderr.splitlines()
                    max_line_length = max(
                        max(len(line) for line in stdout_lines),
                        max(len(line) for line in stderr_lines),
                    )
                    title=' Captured stdout '
                    mark_length = (max_line_length - len(title)) // 2
                    print('| ', '=' * mark_length, title, '=' * mark_length)
                    for line in stdout_lines:
                        print('| ', line)
                    title=' Captured stderr '
                    mark_length = (max_line_length - len(title)) // 2
                    print('| ', '=' * mark_length, title, '=' * mark_length)
                    for line in stderr_lines:
                        print('| ', line)
                if process.returncode != 0:
                    print('└─ ✗ Exited with non-zero exit code: ',
                          process.returncode)
                    if not args.keep_going:
                        sys.exit(process.returncode)
                    exitcode = 1
                else:
                    print('└─ ✓ Done')
        except ValueError as e:
            print('✗ Failed prerequisite lookup: {}'.format(str(e)))
            exitcode = 1
            if not args.keep_going:
                break
    sys.exit(exitcode)
