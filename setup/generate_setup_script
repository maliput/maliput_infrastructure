#!/usr/bin/env python3

import argparse
import os
import re
import sys

import subprocess

import jinja2
import json
import yaml

from urllib.request import urlopen


DOCKERIZED_SETUP_SCRIPT_TEMPLATE = """\
#!/bin/bash

set -eu
set -o pipefail

echo ">>> Checking videocard"

if ! lspci | grep -A 2 -i "VGA" | grep -q -e NVIDIA; then
  echo "NVIDIA card detected"
else
  echo "NVIDIA card not found. Not going to make a docker workspace."
  exit 1
fi

echo ">>> Checking if nvidia-docker is installed"

if dpkg -s nvidia-docker > /dev/null 2>&1; then
  echo "nvidia-docker 1.0 will be removed. Are you sure you want to proceed? This will delete all your images that use nvidia.(y/n)"
  read remove_nvidia_docker
  if [ "$remove_nvidia_docker" != "${remove_nvidia_docker#[Yy]}" ]; then
    docker volume ls -q -f driver=nvidia-docker | xargs -r -I{} -n1 docker ps -q -a -f volume={} | xargs -r docker rm -f
    sudo apt-get purge nvidia-docker
  else
    echo "Not going to proceed with the setup. nvidia-docker2 is required."
    exit 1
  fi
fi

echo ">>> Checking if nvidia-docker2 is installed"
if ! dpkg -s nvidia-docker2 > /dev/null 2>&1; then
  echo ">>>> Installing nvidia-docker2"
  curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \
    sudo apt-key add -
  distribution=$(. /etc/os-release;echo $ID$VERSION_ID)
  curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \
    sudo tee /etc/apt/sources.list.d/nvidia-docker.list
  sudo apt-get update
  sudo apt-get install nvidia-docker2
  sudo pkill -SIGHUP dockerd
  sudo service docker restart
fi

WORKSPACE_PATH=$(realpath ${1:-$(pwd)})
WORKSPACE_SCRIPT=$WORKSPACE_PATH/bringup
WORKSPACE_RCFILE=$WORKSPACE_PATH/.bashrc
USER=$(whoami)
USERID=$(id -u)

IMAGE_NAME=@{ image_name }@
echo ">>> Building $IMAGE_NAME docker image..."

if [ -z "$(docker images -q $IMAGE_NAME 2>/dev/null)" ]; then

echo ">>>>>> Building base $IMAGE_NAME docker image..."
docker build -t $IMAGE_NAME -<<OUTER_EOF
FROM nvidia/opengl:1.0-glvnd-runtime-ubuntu18.04

# Setup nvidia runtime
ENV NVIDIA_VISIBLE_DEVICES \\${NVIDIA_VISIBLE_DEVICES:-all}
ENV NVIDIA_DRIVER_CAPABILITIES \\
   \\${NVIDIA_DRIVER_CAPABILITIES:+\\$NVIDIA_DRIVER_CAPABILITIES,}graphics

# Setup environment
ENV TERM linux
ENV DEBIAN_FRONTEND noninteractive
RUN echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections
RUN apt update
RUN apt install -y locales
RUN locale-gen en_US.UTF-8
ENV LANG en_US.UTF-8

# Install base system dependencies
RUN apt install -y sudo tmux openssh-server software-properties-common \\
   bash-completion debian-keyring debian-archive-keyring

# Create a user with passwordless sudo
RUN adduser --uid $USERID --gecos "Maliput Developer" --disabled-password $USER
RUN adduser $USER sudo
RUN echo '%sudo ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers
RUN echo "export QT_X11_NO_MITSHM=1" >> /home/$USER/.bashrc

USER $USER
OUTER_EOF

fi

echo ">>>>>> Updating $IMAGE_NAME docker image in temporary container..."
CONTAINER_NAME="${IMAGE_NAME//:/_}_build_$(date +%s)"

cat > $WORKSPACE_PATH/setup <<"OUTER_EOF"
@{ base_script }@
OUTER_EOF
chmod +x $WORKSPACE_PATH/setup

docker run --privileged --net=host --runtime=nvidia \\
  --name $CONTAINER_NAME -w $WORKSPACE_PATH \\
  -v /home/$USER/.ssh:/home/$USER/.ssh \\
  -v $WORKSPACE_PATH:$WORKSPACE_PATH \\
  -it $IMAGE_NAME $WORKSPACE_PATH/setup

rm $WORKSPACE_PATH/setup

echo ">>>>>> Committing $IMAGE_NAME docker image..."
docker commit $CONTAINER_NAME $IMAGE_NAME

echo ">>>>>> Cleaning up temporary container..."
docker stop $CONTAINER_NAME > /dev/null
docker rm $CONTAINER_NAME > /dev/null

echo ">>> Done building $IMAGE_NAME docker image."

cat > $WORKSPACE_SCRIPT <<OUTER_EOF
# Bring up workspace as necessary

xhost +
docker run --privileged --rm --net=host \\\\
    -e DISPLAY=\\$DISPLAY --runtime=nvidia \\\\
    -w $WORKSPACE_PATH -v $WORKSPACE_PATH:$WORKSPACE_PATH \\\\
    -v /home/$USER/.ssh:/home/$USER/.ssh \\\\
    -v /tmp/.X11-unix:/tmp/.X11-unix:ro \$@ \\\\
    -it $IMAGE_NAME /bin/bash --rcfile $WORKSPACE_RCFILE
OUTER_EOF
"""

SETUP_SCRIPT_TEMPLATE = """\
#!/bin/bash
set -eu
set -o pipefail

WORKSPACE_PATH=$(realpath ${1:-$(pwd)})
WORKSPACE_SCRIPT=$WORKSPACE_PATH/bringup
WORKSPACE_RCFILE=$WORKSPACE_PATH/.bashrc

echo ">>> Installing base dependencies..."

# We've seen the "default" keyserver (p80.pool.sks-keyservers.net) fail somewhat
# often.  This function will try the default, followed by some alternates to
# reduce the number of times builds fail because of key problems.
pull_apt_keys() {
    success=0
    for keyserver in hkp://p80.pool.sks-keyservers.net:80 hkp://pgp.mit.edu:80 hkp://keyserver.ubuntu.com:80 ; do
        sudo apt-key adv --keyserver $keyserver --recv-keys $1 || continue
        success=1
        break
    done

    if [ $success -eq 0 ]; then
        echo "Failed to pull from keyservers"
        exit 1
    fi
}

install_apt_repo() {
  REPO_NAME=$1
  REPO_URL=$2
  REPO_KEY=$3

  if ! grep -q "^deb .*$REPO_URL" /etc/apt/sources.list /etc/apt/sources.list.d/*; then
    echo "deb $REPO_URL $(lsb_release -cs) main" | \\
      sudo tee --append /etc/apt/sources.list.d/$REPO_NAME.list > /dev/null
    pull_apt_keys $REPO_KEY
    echo "Apt Repo '$REPO_NAME'..........................installed"
  else
    echo "Apt Repo '$REPO_NAME'..........................found"
  fi
}

echo ">>>>>> Updating apt sources..."

install_apt_repo "gazebo-stable" "http://packages.osrfoundation.org/gazebo/ubuntu-stable" "D2486D2DD83DB69272AFE98867170598AF249743"
install_apt_repo "ros-latest" "http://packages.ros.org/ros/ubuntu" "421C365BD9FF1F717815A3895523BAEEB01FA116"

sudo apt update

echo ">>>>>> Installing common tools..."
export DEBIAN_FRONTEND=noninteractive

sudo apt install -y \\
   curl \\
   git \\
   mercurial \\
   python3  \\
   python3-setuptools \\
   python3-vcstool \\
   python3-colcon-common-extensions

@% if with_drake_nightly %@
echo ">>>>>> Cleaning any existing install of drake nightly in '/opt/drake'"
sudo rm -rf /opt/drake

echo ">>>>>> Installing drake nightly into '/opt/drake'"
sudo mkdir -p /opt/drake

echo ">>>>>>>>> Downloading drake tarball..."
curl -o /tmp/drake.tar.gz @{ with_drake_nightly }@

echo ">>>>>>>>> Extracting drake nightly tarball..."
sudo tar xvz -f /tmp/drake.tar.gz -C /opt/drake --strip 1
rm /tmp/drake.tar.gz

sudo tee /opt/drake/setup.bash > /dev/null <<EOF
export PYTHONPATH="/opt/drake/lib/python3.6/site-packages:\\${PYTHONPATH:-}"
export LD_LIBRARY_PATH="/opt/drake/lib:\\${LD_LIBRARY_PATH:-}"
export CMAKE_PREFIX_PATH="/opt/drake:\\${CMAKE_PREFIX_PATH:-}"
export PATH="/opt/drake/bin:\\${PATH:-}"
EOF
@% endif %@

@% if with_stable_ignition %@
echo ">>>>>> Installing stable ignition libraries..."
sudo apt install -y \\
    libignition-gui0-dev \\
    libignition-rendering0-dev \\
    libignition-common2-dev \\
    libignition-tools-dev \\
    libignition-cmake1-dev \\
    libignition-math5-dev \\
    libignition-transport5-dev
@% endif %@
echo ">>> Done installing dependencies."

@% if repos %@
echo ">>> Cloning source repositories..."
mkdir -p $WORKSPACE_PATH/src
@% for content in repos %@
vcs import --force $WORKSPACE_PATH/src <<EOF
@{ content }@
EOF
@% endfor %@
${POST_CLONE_HOOK:-}
echo ">>> Done cloning source repositories."
@% endif %@

@% if with_drake_nightly %@
echo ">>> Installing drake binary prerequisites..."
set +o pipefail
yes | sudo /opt/drake/share/drake/setup/install_prereqs
set -o pipefail
echo ">>> Done installing latest drake nightly."
@% endif %@

mkdir -p $WORKSPACE_PATH/src
PREREQ_SCRIPTS=$(find $WORKSPACE_PATH/src -name 'install_prereqs*')
if [ ! -z "$PREREQ_SCRIPTS" ]; then
echo ">>> Installing source repositories prerequisites..."
set +o pipefail
for script in "$PREREQ_SCRIPTS"; do
    yes | sudo $script
done
set -o pipefail
echo ">>> Done installing source repositories prerequisites."
fi

cat > $WORKSPACE_RCFILE <<EOF
# Source system wide rcfile.
source /etc/bash.bashrc

# Source user specific rcfile.
source ~/.bashrc

# Let the user know this is another environment.
export PS1="($(basename $WORKSPACE_PATH) env) \\${PS1:-}"

@% if with_drake_nightly %@
# Source Drake installation.
source /opt/drake/setup.bash
@% endif %@
EOF

cat > $WORKSPACE_SCRIPT <<EOF
# Bring up workspace as necessary

/bin/bash --rcfile $WORKSPACE_RCFILE
EOF
"""


def deduce_drake_nightly_url(version):
    """Determine drake nightly binaries download URL for a given commit or branch."""
    if version == 'master':
        return 'https://drake-packages.csail.mit.edu/drake/nightly/drake-latest-bionic.tar.gz'
    if re.match(r'[0-9a-f]{12,}', version) is not None:
        with urlopen('https://api.github.com/repos/RobotLocomotion/drake/commits/' + version) as f:
            data = json.loads(f.read().decode())
            commit_date = data['commit']['committer']['date']
    else:
        with urlopen('https://api.github.com/repos/RobotLocomotion/drake/branches/' + version) as f:
            data = json.loads(f.read().decode())
            commit_date = data['commit']['commit']['committer']['date']
    return 'https://drake-packages.csail.mit.edu/drake/nightly/drake-{}-bionic.tar.gz'.format(
        commit_date.replace('-', '')[:8]
    )


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Bootstrap maliput development workspace',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        '-o', '--output', type=argparse.FileType('w'),
        default=sys.stdout, help='Output for generated script.'
    )
    parser.add_argument(
        '-r', '--repos', type=argparse.FileType('r'), action='append',
        default=[], help='Repos files to import into the workspace.'
    )
    parser.add_argument(
        '--inside-docker', nargs='?', metavar='image-name',
        const='$(basename $WORKSPACE_PATH)', default=None,
        help='Setup workspace within a docker container.',
    )
    parser.add_argument(
        '--with-drake-nightly', action='store', default=None,
        help=('Install drake nightly tarball, either from a given URL '
              'or from a the URL that matches the version in .repos file')
    )
    parser.add_argument(
        '--with-stable-ignition', action='store_true', default=False,
        help='Install stable ignition debian binaries.',
    )
    parser.add_argument(
        '--with-deb', dest='with_debians', action='append', default=[],
        help='Install additional debian dependencies.'
    )
    args = parser.parse_args()

    env = jinja2.Environment(
        block_start_string="@%", block_end_string="%@",
        variable_start_string="@{", variable_end_string="}@",
        comment_start_string="@#", comment_end_string="@#"
    )
    if args.inside_docker is not None:
        template = env.from_string(DOCKERIZED_SETUP_SCRIPT_TEMPLATE)
        generate_base_setup_script = [__file__]
        for repo_file in args.repos:
            generate_base_setup_script.extend(['-r', repo_file.name])
        if args.with_drake_nightly:
            generate_base_setup_script.extend([
                '--with-drake-nightly', args.with_drake_nightly
            ])
        if args.with_stable_ignition:
            generate_base_setup_script.append('--with-stable-ignition')
        for deb in args.with_debians:
            generate_base_setup_script.extend(['--with-deb', deb])
        context = {
            'image_name': args.inside_docker,
            'base_script': subprocess.check_output(
                generate_base_setup_script).decode()
        }
    else:
        if args.with_drake_nightly is not None:
            if os.path.isfile(args.with_drake_nightly):
                with open(args.with_drake_nightly, 'r') as f:
                    data = yaml.load(f.read())
                    args.with_drake_nightly = deduce_drake_nightly_url(
                        data['repositories']['drake']['version']
                    )
        context = {
            'repos': [repo_file.read().strip('\n') for repo_file in args.repos],
            'with_debians': args.with_debians,
            'with_drake_nightly': args.with_drake_nightly,
            'with_stable_ignition': args.with_stable_ignition,
        }
        template = env.from_string(SETUP_SCRIPT_TEMPLATE)
    args.output.write(
        re.sub(os.linesep + '{3,}', os.linesep * 2,
               template.render(**context)) + os.linesep
    )
    if os.path.isfile(args.output.name):
        os.chmod(args.output.name, 0o755)
